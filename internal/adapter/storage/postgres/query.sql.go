// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPropertiesByOwner = `-- name: CountPropertiesByOwner :one
SELECT COUNT(*) FROM properties
WHERE owner_id = $1 AND is_active = true
`

func (q *Queries) CountPropertiesByOwner(ctx context.Context, ownerID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertiesByOwner, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPropertiesByOwnerAndType = `-- name: CountPropertiesByOwnerAndType :one
SELECT COUNT(*) FROM properties
WHERE owner_id = $1 AND rental_type = $2 AND is_active = true
`

type CountPropertiesByOwnerAndTypeParams struct {
	OwnerID    pgtype.Int4  `json:"owner_id"`
	RentalType PropertyType `json:"rental_type"`
}

func (q *Queries) CountPropertiesByOwnerAndType(ctx context.Context, arg CountPropertiesByOwnerAndTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertiesByOwnerAndType, arg.OwnerID, arg.RentalType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCreditTransaction = `-- name: CreateCreditTransaction :one
INSERT INTO credit_transactions (
    user_id, amount, transaction_type, description
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, user_id, amount, transaction_type, description, created_at
`

type CreateCreditTransactionParams struct {
	UserID          pgtype.Int4 `json:"user_id"`
	Amount          int32       `json:"amount"`
	TransactionType string      `json:"transaction_type"`
	Description     pgtype.Text `json:"description"`
}

func (q *Queries) CreateCreditTransaction(ctx context.Context, arg CreateCreditTransactionParams) (CreditTransaction, error) {
	row := q.db.QueryRow(ctx, createCreditTransaction,
		arg.UserID,
		arg.Amount,
		arg.TransactionType,
		arg.Description,
	)
	var i CreditTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.TransactionType,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createProperty = `-- name: CreateProperty :one
INSERT INTO properties (
  owner_id,
  address,
  rental_type,
  details
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, owner_id, address, rental_type, details, is_active, created_at
`

type CreatePropertyParams struct {
	OwnerID    pgtype.Int4  `json:"owner_id"`
	Address    string       `json:"address"`
	RentalType PropertyType `json:"rental_type"`
	Details    []byte       `json:"details"`
}

func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, createProperty,
		arg.OwnerID,
		arg.Address,
		arg.RentalType,
		arg.Details,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Address,
		&i.RentalType,
		&i.Details,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createSolvencyCheck = `-- name: CreateSolvencyCheck :one
INSERT INTO solvency_checks (
    initiator_owner_id, candidate_email, property_id, status
) VALUES (
    $1, $2, $3, 'pending'
)
RETURNING id, initiator_owner_id, candidate_email, property_id, status, score_result, report_url, documents_json, created_at
`

type CreateSolvencyCheckParams struct {
	InitiatorOwnerID pgtype.Int4 `json:"initiator_owner_id"`
	CandidateEmail   string      `json:"candidate_email"`
	PropertyID       pgtype.Int4 `json:"property_id"`
}

func (q *Queries) CreateSolvencyCheck(ctx context.Context, arg CreateSolvencyCheckParams) (SolvencyCheck, error) {
	row := q.db.QueryRow(ctx, createSolvencyCheck, arg.InitiatorOwnerID, arg.CandidateEmail, arg.PropertyID)
	var i SolvencyCheck
	err := row.Scan(
		&i.ID,
		&i.InitiatorOwnerID,
		&i.CandidateEmail,
		&i.PropertyID,
		&i.Status,
		&i.ScoreResult,
		&i.ReportUrl,
		&i.DocumentsJson,
		&i.CreatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
    user_id, plan_type, frequency, start_date, end_date, max_properties_limit
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, user_id, plan_type, frequency, status, start_date, end_date, max_properties_limit, created_at
`

type CreateSubscriptionParams struct {
	UserID             pgtype.Int4     `json:"user_id"`
	PlanType           SubPlan         `json:"plan_type"`
	Frequency          NullBillingFreq `json:"frequency"`
	StartDate          pgtype.Date     `json:"start_date"`
	EndDate            pgtype.Date     `json:"end_date"`
	MaxPropertiesLimit pgtype.Int4     `json:"max_properties_limit"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.UserID,
		arg.PlanType,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.MaxPropertiesLimit,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanType,
		&i.Frequency,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.MaxPropertiesLimit,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  email,
  password_hash,
  first_name,
  last_name,
  phone_number
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, created_at
`

type CreateUserParams struct {
	Email        string      `json:"email"`
	PasswordHash string      `json:"password_hash"`
	FirstName    pgtype.Text `json:"first_name"`
	LastName     pgtype.Text `json:"last_name"`
	PhoneNumber  pgtype.Text `json:"phone_number"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.CreatedAt,
	)
	return i, err
}

const getProperty = `-- name: GetProperty :one
SELECT id, owner_id, address, rental_type, details, is_active, created_at FROM properties
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProperty(ctx context.Context, id int32) (Property, error) {
	row := q.db.QueryRow(ctx, getProperty, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Address,
		&i.RentalType,
		&i.Details,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, created_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.CreatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, created_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.CreatedAt,
	)
	return i, err
}

const getUserCreditBalance = `-- name: GetUserCreditBalance :one
SELECT current_balance::int FROM view_user_credit_balance
WHERE user_id = $1
`

func (q *Queries) GetUserCreditBalance(ctx context.Context, userID pgtype.Int4) (int32, error) {
	row := q.db.QueryRow(ctx, getUserCreditBalance, userID)
	var current_balance int32
	err := row.Scan(&current_balance)
	return current_balance, err
}

const getUserSubscription = `-- name: GetUserSubscription :one
SELECT id, user_id, plan_type, frequency, status, start_date, end_date, max_properties_limit, created_at FROM subscriptions
WHERE user_id = $1 AND status = 'active'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUserSubscription(ctx context.Context, userID pgtype.Int4) (Subscription, error) {
	row := q.db.QueryRow(ctx, getUserSubscription, userID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanType,
		&i.Frequency,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.MaxPropertiesLimit,
		&i.CreatedAt,
	)
	return i, err
}

const hasReceivedInitialBonus = `-- name: HasReceivedInitialBonus :one
SELECT EXISTS(
    SELECT 1 FROM credit_transactions
    WHERE user_id = $1 AND transaction_type = 'initial_free'
)
`

func (q *Queries) HasReceivedInitialBonus(ctx context.Context, userID pgtype.Int4) (bool, error) {
	row := q.db.QueryRow(ctx, hasReceivedInitialBonus, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listPropertiesByOwner = `-- name: ListPropertiesByOwner :many
SELECT id, owner_id, address, rental_type, details, is_active, created_at FROM properties
WHERE owner_id = $1 AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) ListPropertiesByOwner(ctx context.Context, ownerID pgtype.Int4) ([]Property, error) {
	rows, err := q.db.Query(ctx, listPropertiesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Property
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Address,
			&i.RentalType,
			&i.Details,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProperty = `-- name: SoftDeleteProperty :one
UPDATE properties
SET is_active = false
WHERE id = $1 AND owner_id = $2 AND is_active = true
RETURNING id
`

type SoftDeletePropertyParams struct {
	ID      int32       `json:"id"`
	OwnerID pgtype.Int4 `json:"owner_id"`
}

func (q *Queries) SoftDeleteProperty(ctx context.Context, arg SoftDeletePropertyParams) (int32, error) {
	row := q.db.QueryRow(ctx, softDeleteProperty, arg.ID, arg.OwnerID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateSubscriptionLimit = `-- name: UpdateSubscriptionLimit :exec
UPDATE subscriptions
SET max_properties_limit = max_properties_limit + $2
WHERE user_id = $1 AND status = 'active'
`

type UpdateSubscriptionLimitParams struct {
	UserID             pgtype.Int4 `json:"user_id"`
	MaxPropertiesLimit pgtype.Int4 `json:"max_properties_limit"`
}

func (q *Queries) UpdateSubscriptionLimit(ctx context.Context, arg UpdateSubscriptionLimitParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionLimit, arg.UserID, arg.MaxPropertiesLimit)
	return err
}
