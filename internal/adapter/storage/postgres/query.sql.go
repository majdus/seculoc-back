// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countBookingsByTenant = `-- name: CountBookingsByTenant :one
SELECT COUNT(*) FROM seasonal_bookings
WHERE tenant_id = $1 AND booking_status = 'confirmed'
`

func (q *Queries) CountBookingsByTenant(ctx context.Context, tenantID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countBookingsByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLeasesByTenant = `-- name: CountLeasesByTenant :one
SELECT COUNT(*) FROM leases
WHERE tenant_id = $1 AND lease_status != 'terminated'
`

func (q *Queries) CountLeasesByTenant(ctx context.Context, tenantID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countLeasesByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPropertiesByOwner = `-- name: CountPropertiesByOwner :one
SELECT COUNT(*) FROM properties
WHERE owner_id = $1 AND is_active = true
`

func (q *Queries) CountPropertiesByOwner(ctx context.Context, ownerID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertiesByOwner, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPropertiesByOwnerAndType = `-- name: CountPropertiesByOwnerAndType :one
SELECT COUNT(*) FROM properties
WHERE owner_id = $1 AND rental_type = $2 AND is_active = true
`

type CountPropertiesByOwnerAndTypeParams struct {
	OwnerID    pgtype.Int4  `json:"owner_id"`
	RentalType PropertyType `json:"rental_type"`
}

func (q *Queries) CountPropertiesByOwnerAndType(ctx context.Context, arg CountPropertiesByOwnerAndTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertiesByOwnerAndType, arg.OwnerID, arg.RentalType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCreditTransaction = `-- name: CreateCreditTransaction :one
INSERT INTO credit_transactions (
    user_id, amount, transaction_type, description
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, user_id, amount, transaction_type, description, created_at
`

type CreateCreditTransactionParams struct {
	UserID          pgtype.Int4 `json:"user_id"`
	Amount          int32       `json:"amount"`
	TransactionType string      `json:"transaction_type"`
	Description     pgtype.Text `json:"description"`
}

func (q *Queries) CreateCreditTransaction(ctx context.Context, arg CreateCreditTransactionParams) (CreditTransaction, error) {
	row := q.db.QueryRow(ctx, createCreditTransaction,
		arg.UserID,
		arg.Amount,
		arg.TransactionType,
		arg.Description,
	)
	var i CreditTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.TransactionType,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO lease_invitations (property_id, owner_id, tenant_email, token, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, property_id, owner_id, tenant_email, token, status, expires_at, created_at
`

type CreateInvitationParams struct {
	PropertyID  int32            `json:"property_id"`
	OwnerID     int32            `json:"owner_id"`
	TenantEmail string           `json:"tenant_email"`
	Token       string           `json:"token"`
	ExpiresAt   pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (LeaseInvitation, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.PropertyID,
		arg.OwnerID,
		arg.TenantEmail,
		arg.Token,
		arg.ExpiresAt,
	)
	var i LeaseInvitation
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.OwnerID,
		&i.TenantEmail,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createLease = `-- name: CreateLease :one
INSERT INTO leases (
    property_id, tenant_id, start_date, rent_amount, deposit_amount, lease_status
) VALUES (
    $1, $2, $3, $4, $5, 'draft'
)
RETURNING id, property_id, tenant_id, start_date, end_date, rent_amount, deposit_amount, lease_status, contract_url, escrow_deposit_status, created_at
`

type CreateLeaseParams struct {
	PropertyID    pgtype.Int4    `json:"property_id"`
	TenantID      pgtype.Int4    `json:"tenant_id"`
	StartDate     pgtype.Date    `json:"start_date"`
	RentAmount    pgtype.Numeric `json:"rent_amount"`
	DepositAmount pgtype.Numeric `json:"deposit_amount"`
}

func (q *Queries) CreateLease(ctx context.Context, arg CreateLeaseParams) (Lease, error) {
	row := q.db.QueryRow(ctx, createLease,
		arg.PropertyID,
		arg.TenantID,
		arg.StartDate,
		arg.RentAmount,
		arg.DepositAmount,
	)
	var i Lease
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.StartDate,
		&i.EndDate,
		&i.RentAmount,
		&i.DepositAmount,
		&i.LeaseStatus,
		&i.ContractUrl,
		&i.EscrowDepositStatus,
		&i.CreatedAt,
	)
	return i, err
}

const createProperty = `-- name: CreateProperty :one
INSERT INTO properties (
  owner_id,
  address,
  rental_type,
  details,
  rent_amount,
  deposit_amount
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, owner_id, address, rental_type, details, rent_amount, deposit_amount, vacancy_credits, is_active, created_at
`

type CreatePropertyParams struct {
	OwnerID       pgtype.Int4    `json:"owner_id"`
	Address       string         `json:"address"`
	RentalType    PropertyType   `json:"rental_type"`
	Details       []byte         `json:"details"`
	RentAmount    pgtype.Numeric `json:"rent_amount"`
	DepositAmount pgtype.Numeric `json:"deposit_amount"`
}

func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, createProperty,
		arg.OwnerID,
		arg.Address,
		arg.RentalType,
		arg.Details,
		arg.RentAmount,
		arg.DepositAmount,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Address,
		&i.RentalType,
		&i.Details,
		&i.RentAmount,
		&i.DepositAmount,
		&i.VacancyCredits,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createSolvencyCheck = `-- name: CreateSolvencyCheck :one
INSERT INTO solvency_checks (
    initiator_owner_id, candidate_email, property_id, status
) VALUES (
    $1, $2, $3, 'pending'
)
RETURNING id, initiator_owner_id, candidate_email, property_id, status, score_result, report_url, documents_json, created_at
`

type CreateSolvencyCheckParams struct {
	InitiatorOwnerID pgtype.Int4 `json:"initiator_owner_id"`
	CandidateEmail   string      `json:"candidate_email"`
	PropertyID       pgtype.Int4 `json:"property_id"`
}

func (q *Queries) CreateSolvencyCheck(ctx context.Context, arg CreateSolvencyCheckParams) (SolvencyCheck, error) {
	row := q.db.QueryRow(ctx, createSolvencyCheck, arg.InitiatorOwnerID, arg.CandidateEmail, arg.PropertyID)
	var i SolvencyCheck
	err := row.Scan(
		&i.ID,
		&i.InitiatorOwnerID,
		&i.CandidateEmail,
		&i.PropertyID,
		&i.Status,
		&i.ScoreResult,
		&i.ReportUrl,
		&i.DocumentsJson,
		&i.CreatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
    user_id, plan_type, frequency, start_date, end_date, max_properties_limit
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, user_id, plan_type, frequency, status, start_date, end_date, max_properties_limit, created_at
`

type CreateSubscriptionParams struct {
	UserID             pgtype.Int4     `json:"user_id"`
	PlanType           SubPlan         `json:"plan_type"`
	Frequency          NullBillingFreq `json:"frequency"`
	StartDate          pgtype.Date     `json:"start_date"`
	EndDate            pgtype.Date     `json:"end_date"`
	MaxPropertiesLimit pgtype.Int4     `json:"max_properties_limit"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.UserID,
		arg.PlanType,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.MaxPropertiesLimit,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanType,
		&i.Frequency,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.MaxPropertiesLimit,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  email,
  password_hash,
  first_name,
  last_name,
  phone_number,
  last_context_used
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, last_context_used, created_at
`

type CreateUserParams struct {
	Email           string      `json:"email"`
	PasswordHash    string      `json:"password_hash"`
	FirstName       pgtype.Text `json:"first_name"`
	LastName        pgtype.Text `json:"last_name"`
	PhoneNumber     pgtype.Text `json:"phone_number"`
	LastContextUsed pgtype.Text `json:"last_context_used"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.LastContextUsed,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.LastContextUsed,
		&i.CreatedAt,
	)
	return i, err
}

const decreasePropertyCredits = `-- name: DecreasePropertyCredits :exec
UPDATE properties
SET vacancy_credits = vacancy_credits - 1
WHERE id = $1 AND vacancy_credits > 0
`

func (q *Queries) DecreasePropertyCredits(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, decreasePropertyCredits, id)
	return err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT id, property_id, owner_id, tenant_email, token, status, expires_at, created_at FROM lease_invitations
WHERE token = $1 LIMIT 1
`

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (LeaseInvitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByToken, token)
	var i LeaseInvitation
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.OwnerID,
		&i.TenantEmail,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getProperty = `-- name: GetProperty :one
SELECT id, owner_id, address, rental_type, details, rent_amount, deposit_amount, vacancy_credits, is_active, created_at FROM properties
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProperty(ctx context.Context, id int32) (Property, error) {
	row := q.db.QueryRow(ctx, getProperty, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Address,
		&i.RentalType,
		&i.Details,
		&i.RentAmount,
		&i.DepositAmount,
		&i.VacancyCredits,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, last_context_used, created_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.LastContextUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, last_context_used, created_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.LastContextUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getUserCreditBalance = `-- name: GetUserCreditBalance :one
SELECT current_balance::int FROM view_user_credit_balance
WHERE user_id = $1
`

func (q *Queries) GetUserCreditBalance(ctx context.Context, userID pgtype.Int4) (int32, error) {
	row := q.db.QueryRow(ctx, getUserCreditBalance, userID)
	var current_balance int32
	err := row.Scan(&current_balance)
	return current_balance, err
}

const getUserSubscription = `-- name: GetUserSubscription :one
SELECT id, user_id, plan_type, frequency, status, start_date, end_date, max_properties_limit, created_at FROM subscriptions
WHERE user_id = $1 AND status = 'active'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUserSubscription(ctx context.Context, userID pgtype.Int4) (Subscription, error) {
	row := q.db.QueryRow(ctx, getUserSubscription, userID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanType,
		&i.Frequency,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.MaxPropertiesLimit,
		&i.CreatedAt,
	)
	return i, err
}

const hasReceivedInitialBonus = `-- name: HasReceivedInitialBonus :one
SELECT EXISTS(
    SELECT 1 FROM credit_transactions
    WHERE user_id = $1 AND transaction_type = 'initial_free'
)
`

func (q *Queries) HasReceivedInitialBonus(ctx context.Context, userID pgtype.Int4) (bool, error) {
	row := q.db.QueryRow(ctx, hasReceivedInitialBonus, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listLeasesByTenant = `-- name: ListLeasesByTenant :many
SELECT 
    l.id, l.property_id, l.tenant_id, l.start_date, l.end_date, l.rent_amount, l.deposit_amount, l.lease_status, l.contract_url, l.created_at,
    p.address as property_address, p.rental_type
FROM leases l
JOIN properties p ON l.property_id = p.id
WHERE l.tenant_id = $1
ORDER BY l.created_at DESC
`

type ListLeasesByTenantRow struct {
	ID              int32            `json:"id"`
	PropertyID      pgtype.Int4      `json:"property_id"`
	TenantID        pgtype.Int4      `json:"tenant_id"`
	StartDate       pgtype.Date      `json:"start_date"`
	EndDate         pgtype.Date      `json:"end_date"`
	RentAmount      pgtype.Numeric   `json:"rent_amount"`
	DepositAmount   pgtype.Numeric   `json:"deposit_amount"`
	LeaseStatus     pgtype.Text      `json:"lease_status"`
	ContractUrl     pgtype.Text      `json:"contract_url"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	PropertyAddress string           `json:"property_address"`
	RentalType      PropertyType     `json:"rental_type"`
}

func (q *Queries) ListLeasesByTenant(ctx context.Context, tenantID pgtype.Int4) ([]ListLeasesByTenantRow, error) {
	rows, err := q.db.Query(ctx, listLeasesByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLeasesByTenantRow
	for rows.Next() {
		var i ListLeasesByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.StartDate,
			&i.EndDate,
			&i.RentAmount,
			&i.DepositAmount,
			&i.LeaseStatus,
			&i.ContractUrl,
			&i.CreatedAt,
			&i.PropertyAddress,
			&i.RentalType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPropertiesByOwner = `-- name: ListPropertiesByOwner :many
SELECT id, owner_id, address, rental_type, details, rent_amount, deposit_amount, vacancy_credits, is_active, created_at FROM properties
WHERE owner_id = $1 AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) ListPropertiesByOwner(ctx context.Context, ownerID pgtype.Int4) ([]Property, error) {
	rows, err := q.db.Query(ctx, listPropertiesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Property
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Address,
			&i.RentalType,
			&i.Details,
			&i.RentAmount,
			&i.DepositAmount,
			&i.VacancyCredits,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProperty = `-- name: SoftDeleteProperty :one
UPDATE properties
SET is_active = false
WHERE id = $1 AND owner_id = $2 AND is_active = true
RETURNING id
`

type SoftDeletePropertyParams struct {
	ID      int32       `json:"id"`
	OwnerID pgtype.Int4 `json:"owner_id"`
}

func (q *Queries) SoftDeleteProperty(ctx context.Context, arg SoftDeletePropertyParams) (int32, error) {
	row := q.db.QueryRow(ctx, softDeleteProperty, arg.ID, arg.OwnerID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateInvitationStatus = `-- name: UpdateInvitationStatus :exec
UPDATE lease_invitations
SET status = $2
WHERE id = $1
`

type UpdateInvitationStatusParams struct {
	ID     int32       `json:"id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdateInvitationStatus(ctx context.Context, arg UpdateInvitationStatusParams) error {
	_, err := q.db.Exec(ctx, updateInvitationStatus, arg.ID, arg.Status)
	return err
}

const updateLastContext = `-- name: UpdateLastContext :exec
UPDATE users
SET last_context_used = $2
WHERE id = $1
`

type UpdateLastContextParams struct {
	ID              int32       `json:"id"`
	LastContextUsed pgtype.Text `json:"last_context_used"`
}

func (q *Queries) UpdateLastContext(ctx context.Context, arg UpdateLastContextParams) error {
	_, err := q.db.Exec(ctx, updateLastContext, arg.ID, arg.LastContextUsed)
	return err
}

const updateSubscriptionLimit = `-- name: UpdateSubscriptionLimit :exec
UPDATE subscriptions
SET max_properties_limit = max_properties_limit + $2
WHERE user_id = $1 AND status = 'active'
`

type UpdateSubscriptionLimitParams struct {
	UserID             pgtype.Int4 `json:"user_id"`
	MaxPropertiesLimit pgtype.Int4 `json:"max_properties_limit"`
}

func (q *Queries) UpdateSubscriptionLimit(ctx context.Context, arg UpdateSubscriptionLimitParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionLimit, arg.UserID, arg.MaxPropertiesLimit)
	return err
}
