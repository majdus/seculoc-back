// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelSolvencyCheck = `-- name: CancelSolvencyCheck :exec
UPDATE solvency_checks
SET status = 'cancelled'
WHERE id = $1
`

func (q *Queries) CancelSolvencyCheck(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, cancelSolvencyCheck, id)
	return err
}

const cleanupProvisionalUsers = `-- name: CleanupProvisionalUsers :exec
DELETE FROM users 
WHERE is_provisional = TRUE 
AND created_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) CleanupProvisionalUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupProvisionalUsers)
	return err
}

const countBookingsByTenant = `-- name: CountBookingsByTenant :one
SELECT COUNT(*) FROM seasonal_bookings
WHERE tenant_id = $1 AND booking_status = 'confirmed'
`

func (q *Queries) CountBookingsByTenant(ctx context.Context, tenantID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countBookingsByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLeasesByTenant = `-- name: CountLeasesByTenant :one
SELECT COUNT(*) FROM leases
WHERE tenant_id = $1 AND lease_status != 'terminated'
`

func (q *Queries) CountLeasesByTenant(ctx context.Context, tenantID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countLeasesByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPropertiesByOwner = `-- name: CountPropertiesByOwner :one
SELECT COUNT(*) FROM properties
WHERE owner_id = $1 AND is_active = true
`

func (q *Queries) CountPropertiesByOwner(ctx context.Context, ownerID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertiesByOwner, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPropertiesByOwnerAndType = `-- name: CountPropertiesByOwnerAndType :one
SELECT COUNT(*) FROM properties
WHERE owner_id = $1 AND rental_type = $2 AND is_active = true
`

type CountPropertiesByOwnerAndTypeParams struct {
	OwnerID    pgtype.Int4  `json:"owner_id"`
	RentalType PropertyType `json:"rental_type"`
}

func (q *Queries) CountPropertiesByOwnerAndType(ctx context.Context, arg CountPropertiesByOwnerAndTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertiesByOwnerAndType, arg.OwnerID, arg.RentalType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCreditTransaction = `-- name: CreateCreditTransaction :one
INSERT INTO credit_transactions (
    user_id, amount, transaction_type, description
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, user_id, amount, transaction_type, description, created_at
`

type CreateCreditTransactionParams struct {
	UserID          pgtype.Int4 `json:"user_id"`
	Amount          int32       `json:"amount"`
	TransactionType string      `json:"transaction_type"`
	Description     pgtype.Text `json:"description"`
}

func (q *Queries) CreateCreditTransaction(ctx context.Context, arg CreateCreditTransactionParams) (CreditTransaction, error) {
	row := q.db.QueryRow(ctx, createCreditTransaction,
		arg.UserID,
		arg.Amount,
		arg.TransactionType,
		arg.Description,
	)
	var i CreditTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.TransactionType,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO lease_invitations (property_id, owner_id, tenant_email, token, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, property_id, owner_id, tenant_email, token, status, expires_at, created_at
`

type CreateInvitationParams struct {
	PropertyID  int32            `json:"property_id"`
	OwnerID     int32            `json:"owner_id"`
	TenantEmail string           `json:"tenant_email"`
	Token       string           `json:"token"`
	ExpiresAt   pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (LeaseInvitation, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.PropertyID,
		arg.OwnerID,
		arg.TenantEmail,
		arg.Token,
		arg.ExpiresAt,
	)
	var i LeaseInvitation
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.OwnerID,
		&i.TenantEmail,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createLease = `-- name: CreateLease :one
INSERT INTO leases (
    property_id, tenant_id, start_date, rent_amount, deposit_amount, lease_status
) VALUES (
    $1, $2, $3, $4, $5, 'draft'
)
RETURNING id, property_id, tenant_id, start_date, end_date, rent_amount, deposit_amount, lease_status, contract_url, escrow_deposit_status, created_at
`

type CreateLeaseParams struct {
	PropertyID    pgtype.Int4    `json:"property_id"`
	TenantID      pgtype.Int4    `json:"tenant_id"`
	StartDate     pgtype.Date    `json:"start_date"`
	RentAmount    pgtype.Numeric `json:"rent_amount"`
	DepositAmount pgtype.Numeric `json:"deposit_amount"`
}

func (q *Queries) CreateLease(ctx context.Context, arg CreateLeaseParams) (Lease, error) {
	row := q.db.QueryRow(ctx, createLease,
		arg.PropertyID,
		arg.TenantID,
		arg.StartDate,
		arg.RentAmount,
		arg.DepositAmount,
	)
	var i Lease
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.StartDate,
		&i.EndDate,
		&i.RentAmount,
		&i.DepositAmount,
		&i.LeaseStatus,
		&i.ContractUrl,
		&i.EscrowDepositStatus,
		&i.CreatedAt,
	)
	return i, err
}

const createProperty = `-- name: CreateProperty :one
INSERT INTO properties (
  owner_id, name, address, rental_type, details, rent_amount, rent_charges_amount, deposit_amount, is_furnished, seasonal_price_per_night
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, owner_id, name, address, rental_type, details, rent_amount, rent_charges_amount, deposit_amount, is_furnished, seasonal_price_per_night, vacancy_credits, is_active, created_at
`

type CreatePropertyParams struct {
	OwnerID               pgtype.Int4    `json:"owner_id"`
	Name                  pgtype.Text    `json:"name"`
	Address               string         `json:"address"`
	RentalType            PropertyType   `json:"rental_type"`
	Details               []byte         `json:"details"`
	RentAmount            pgtype.Numeric `json:"rent_amount"`
	RentChargesAmount     pgtype.Numeric `json:"rent_charges_amount"`
	DepositAmount         pgtype.Numeric `json:"deposit_amount"`
	IsFurnished           pgtype.Bool    `json:"is_furnished"`
	SeasonalPricePerNight pgtype.Numeric `json:"seasonal_price_per_night"`
}

func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, createProperty,
		arg.OwnerID,
		arg.Name,
		arg.Address,
		arg.RentalType,
		arg.Details,
		arg.RentAmount,
		arg.RentChargesAmount,
		arg.DepositAmount,
		arg.IsFurnished,
		arg.SeasonalPricePerNight,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Address,
		&i.RentalType,
		&i.Details,
		&i.RentAmount,
		&i.RentChargesAmount,
		&i.DepositAmount,
		&i.IsFurnished,
		&i.SeasonalPricePerNight,
		&i.VacancyCredits,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createSolvencyCheck = `-- name: CreateSolvencyCheck :one
INSERT INTO solvency_checks (
    initiator_owner_id, candidate_id, token, property_id, status, credit_source
) VALUES (
    $1, $2, $3, $4, 'pending', $5
)
RETURNING id, initiator_owner_id, candidate_id, token, property_id, status, credit_source, score_result, report_url, documents_json, created_at
`

type CreateSolvencyCheckParams struct {
	InitiatorOwnerID pgtype.Int4 `json:"initiator_owner_id"`
	CandidateID      pgtype.Int4 `json:"candidate_id"`
	Token            pgtype.Text `json:"token"`
	PropertyID       pgtype.Int4 `json:"property_id"`
	CreditSource     pgtype.Text `json:"credit_source"`
}

func (q *Queries) CreateSolvencyCheck(ctx context.Context, arg CreateSolvencyCheckParams) (SolvencyCheck, error) {
	row := q.db.QueryRow(ctx, createSolvencyCheck,
		arg.InitiatorOwnerID,
		arg.CandidateID,
		arg.Token,
		arg.PropertyID,
		arg.CreditSource,
	)
	var i SolvencyCheck
	err := row.Scan(
		&i.ID,
		&i.InitiatorOwnerID,
		&i.CandidateID,
		&i.Token,
		&i.PropertyID,
		&i.Status,
		&i.CreditSource,
		&i.ScoreResult,
		&i.ReportUrl,
		&i.DocumentsJson,
		&i.CreatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
    user_id, plan_type, frequency, start_date, end_date, max_properties_limit
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, user_id, plan_type, frequency, status, start_date, end_date, max_properties_limit, created_at
`

type CreateSubscriptionParams struct {
	UserID             pgtype.Int4     `json:"user_id"`
	PlanType           SubPlan         `json:"plan_type"`
	Frequency          NullBillingFreq `json:"frequency"`
	StartDate          pgtype.Date     `json:"start_date"`
	EndDate            pgtype.Date     `json:"end_date"`
	MaxPropertiesLimit pgtype.Int4     `json:"max_properties_limit"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.UserID,
		arg.PlanType,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.MaxPropertiesLimit,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanType,
		&i.Frequency,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.MaxPropertiesLimit,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  email,
  password_hash,
  first_name,
  last_name,
  phone_number,
  last_context_used
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, is_provisional, last_context_used, created_at
`

type CreateUserParams struct {
	Email           string      `json:"email"`
	PasswordHash    pgtype.Text `json:"password_hash"`
	FirstName       pgtype.Text `json:"first_name"`
	LastName        pgtype.Text `json:"last_name"`
	PhoneNumber     pgtype.Text `json:"phone_number"`
	LastContextUsed pgtype.Text `json:"last_context_used"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.LastContextUsed,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.IsProvisional,
		&i.LastContextUsed,
		&i.CreatedAt,
	)
	return i, err
}

const decreasePropertyCredits = `-- name: DecreasePropertyCredits :exec
UPDATE properties
SET vacancy_credits = vacancy_credits - 1
WHERE id = $1 AND vacancy_credits > 0
`

func (q *Queries) DecreasePropertyCredits(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, decreasePropertyCredits, id)
	return err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT id, property_id, owner_id, tenant_email, token, status, expires_at, created_at FROM lease_invitations
WHERE token = $1 LIMIT 1
`

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (LeaseInvitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByToken, token)
	var i LeaseInvitation
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.OwnerID,
		&i.TenantEmail,
		&i.Token,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getLease = `-- name: GetLease :one
SELECT id, property_id, tenant_id, start_date, end_date, rent_amount, deposit_amount, lease_status, contract_url, escrow_deposit_status, created_at FROM leases
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetLease(ctx context.Context, id int32) (Lease, error) {
	row := q.db.QueryRow(ctx, getLease, id)
	var i Lease
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.StartDate,
		&i.EndDate,
		&i.RentAmount,
		&i.DepositAmount,
		&i.LeaseStatus,
		&i.ContractUrl,
		&i.EscrowDepositStatus,
		&i.CreatedAt,
	)
	return i, err
}

const getProperty = `-- name: GetProperty :one
SELECT id, owner_id, name, address, rental_type, details, rent_amount, rent_charges_amount, deposit_amount, is_furnished, seasonal_price_per_night, vacancy_credits, is_active, created_at FROM properties
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProperty(ctx context.Context, id int32) (Property, error) {
	row := q.db.QueryRow(ctx, getProperty, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Address,
		&i.RentalType,
		&i.Details,
		&i.RentAmount,
		&i.RentChargesAmount,
		&i.DepositAmount,
		&i.IsFurnished,
		&i.SeasonalPricePerNight,
		&i.VacancyCredits,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getPropertyForUpdate = `-- name: GetPropertyForUpdate :one
SELECT id, owner_id, name, address, rental_type, details, rent_amount, rent_charges_amount, deposit_amount, is_furnished, seasonal_price_per_night, vacancy_credits, is_active, created_at FROM properties
WHERE id = $1 FOR UPDATE
`

func (q *Queries) GetPropertyForUpdate(ctx context.Context, id int32) (Property, error) {
	row := q.db.QueryRow(ctx, getPropertyForUpdate, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Address,
		&i.RentalType,
		&i.Details,
		&i.RentAmount,
		&i.RentChargesAmount,
		&i.DepositAmount,
		&i.IsFurnished,
		&i.SeasonalPricePerNight,
		&i.VacancyCredits,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getSolvencyCheckByID = `-- name: GetSolvencyCheckByID :one
SELECT id, initiator_owner_id, candidate_id, token, property_id, status, credit_source, score_result, report_url, documents_json, created_at FROM solvency_checks
WHERE id = $1
`

func (q *Queries) GetSolvencyCheckByID(ctx context.Context, id int32) (SolvencyCheck, error) {
	row := q.db.QueryRow(ctx, getSolvencyCheckByID, id)
	var i SolvencyCheck
	err := row.Scan(
		&i.ID,
		&i.InitiatorOwnerID,
		&i.CandidateID,
		&i.Token,
		&i.PropertyID,
		&i.Status,
		&i.CreditSource,
		&i.ScoreResult,
		&i.ReportUrl,
		&i.DocumentsJson,
		&i.CreatedAt,
	)
	return i, err
}

const getSolvencyCheckByToken = `-- name: GetSolvencyCheckByToken :one
SELECT 
    sc.id, sc.initiator_owner_id, sc.candidate_id, sc.token, sc.property_id, sc.status, sc.created_at,
    u.email as candidate_email, u.first_name as candidate_first_name, u.last_name as candidate_last_name,
    p.address as property_address, p.rent_amount as property_rent_amount, p.name as property_name
FROM solvency_checks sc
JOIN users u ON sc.candidate_id = u.id
JOIN properties p ON sc.property_id = p.id
WHERE sc.token = $1
 LIMIT 1
`

type GetSolvencyCheckByTokenRow struct {
	ID                 int32              `json:"id"`
	InitiatorOwnerID   pgtype.Int4        `json:"initiator_owner_id"`
	CandidateID        pgtype.Int4        `json:"candidate_id"`
	Token              pgtype.Text        `json:"token"`
	PropertyID         pgtype.Int4        `json:"property_id"`
	Status             NullSolvencyStatus `json:"status"`
	CreatedAt          pgtype.Timestamp   `json:"created_at"`
	CandidateEmail     string             `json:"candidate_email"`
	CandidateFirstName pgtype.Text        `json:"candidate_first_name"`
	CandidateLastName  pgtype.Text        `json:"candidate_last_name"`
	PropertyAddress    string             `json:"property_address"`
	PropertyRentAmount pgtype.Numeric     `json:"property_rent_amount"`
	PropertyName       pgtype.Text        `json:"property_name"`
}

func (q *Queries) GetSolvencyCheckByToken(ctx context.Context, token pgtype.Text) (GetSolvencyCheckByTokenRow, error) {
	row := q.db.QueryRow(ctx, getSolvencyCheckByToken, token)
	var i GetSolvencyCheckByTokenRow
	err := row.Scan(
		&i.ID,
		&i.InitiatorOwnerID,
		&i.CandidateID,
		&i.Token,
		&i.PropertyID,
		&i.Status,
		&i.CreatedAt,
		&i.CandidateEmail,
		&i.CandidateFirstName,
		&i.CandidateLastName,
		&i.PropertyAddress,
		&i.PropertyRentAmount,
		&i.PropertyName,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, is_provisional, last_context_used, created_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.IsProvisional,
		&i.LastContextUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, is_provisional, last_context_used, created_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.IsProvisional,
		&i.LastContextUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getUserCreditBalance = `-- name: GetUserCreditBalance :one
SELECT current_balance::int FROM view_user_credit_balance
WHERE user_id = $1
`

func (q *Queries) GetUserCreditBalance(ctx context.Context, userID pgtype.Int4) (int32, error) {
	row := q.db.QueryRow(ctx, getUserCreditBalance, userID)
	var current_balance int32
	err := row.Scan(&current_balance)
	return current_balance, err
}

const getUserCreditBalanceForUpdate = `-- name: GetUserCreditBalanceForUpdate :one
SELECT current_balance::int FROM view_user_credit_balance
WHERE user_id = $1
`

func (q *Queries) GetUserCreditBalanceForUpdate(ctx context.Context, userID pgtype.Int4) (int32, error) {
	row := q.db.QueryRow(ctx, getUserCreditBalanceForUpdate, userID)
	var current_balance int32
	err := row.Scan(&current_balance)
	return current_balance, err
}

const getUserForUpdate = `-- name: GetUserForUpdate :one
SELECT id, email, password_hash, first_name, last_name, phone_number, is_verified, stripe_customer_id, is_provisional, last_context_used, created_at FROM users
WHERE id = $1 FOR UPDATE
`

func (q *Queries) GetUserForUpdate(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserForUpdate, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.IsVerified,
		&i.StripeCustomerID,
		&i.IsProvisional,
		&i.LastContextUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSubscription = `-- name: GetUserSubscription :one
SELECT id, user_id, plan_type, frequency, status, start_date, end_date, max_properties_limit, created_at FROM subscriptions
WHERE user_id = $1 AND status = 'active'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUserSubscription(ctx context.Context, userID pgtype.Int4) (Subscription, error) {
	row := q.db.QueryRow(ctx, getUserSubscription, userID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanType,
		&i.Frequency,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.MaxPropertiesLimit,
		&i.CreatedAt,
	)
	return i, err
}

const hasReceivedInitialBonus = `-- name: HasReceivedInitialBonus :one
SELECT EXISTS(
    SELECT 1 FROM credit_transactions
    WHERE user_id = $1 AND transaction_type = 'initial_free'
)
`

func (q *Queries) HasReceivedInitialBonus(ctx context.Context, userID pgtype.Int4) (bool, error) {
	row := q.db.QueryRow(ctx, hasReceivedInitialBonus, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const increasePropertyCredits = `-- name: IncreasePropertyCredits :exec
UPDATE properties
SET vacancy_credits = vacancy_credits + 1
WHERE id = $1
`

func (q *Queries) IncreasePropertyCredits(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, increasePropertyCredits, id)
	return err
}

const listLeasesByTenant = `-- name: ListLeasesByTenant :many
SELECT 
    l.id, l.property_id, l.tenant_id, l.start_date, l.end_date, l.rent_amount, l.deposit_amount, l.lease_status, l.contract_url, l.created_at,
    p.address as property_address, p.rental_type
FROM leases l
JOIN properties p ON l.property_id = p.id
WHERE l.tenant_id = $1
ORDER BY l.created_at DESC
`

type ListLeasesByTenantRow struct {
	ID              int32            `json:"id"`
	PropertyID      pgtype.Int4      `json:"property_id"`
	TenantID        pgtype.Int4      `json:"tenant_id"`
	StartDate       pgtype.Date      `json:"start_date"`
	EndDate         pgtype.Date      `json:"end_date"`
	RentAmount      pgtype.Numeric   `json:"rent_amount"`
	DepositAmount   pgtype.Numeric   `json:"deposit_amount"`
	LeaseStatus     pgtype.Text      `json:"lease_status"`
	ContractUrl     pgtype.Text      `json:"contract_url"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	PropertyAddress string           `json:"property_address"`
	RentalType      PropertyType     `json:"rental_type"`
}

func (q *Queries) ListLeasesByTenant(ctx context.Context, tenantID pgtype.Int4) ([]ListLeasesByTenantRow, error) {
	rows, err := q.db.Query(ctx, listLeasesByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLeasesByTenantRow
	for rows.Next() {
		var i ListLeasesByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.StartDate,
			&i.EndDate,
			&i.RentAmount,
			&i.DepositAmount,
			&i.LeaseStatus,
			&i.ContractUrl,
			&i.CreatedAt,
			&i.PropertyAddress,
			&i.RentalType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPropertiesByOwner = `-- name: ListPropertiesByOwner :many
SELECT id, owner_id, name, address, rental_type, details, rent_amount, rent_charges_amount, deposit_amount, is_furnished, seasonal_price_per_night, vacancy_credits, is_active, created_at FROM properties
WHERE owner_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPropertiesByOwner(ctx context.Context, ownerID pgtype.Int4) ([]Property, error) {
	rows, err := q.db.Query(ctx, listPropertiesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Property
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Address,
			&i.RentalType,
			&i.Details,
			&i.RentAmount,
			&i.RentChargesAmount,
			&i.DepositAmount,
			&i.IsFurnished,
			&i.SeasonalPricePerNight,
			&i.VacancyCredits,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSolvencyChecksByOwner = `-- name: ListSolvencyChecksByOwner :many
SELECT sc.id, sc.initiator_owner_id, sc.candidate_id, sc.token, sc.property_id, sc.status, sc.credit_source, sc.score_result, sc.report_url, sc.documents_json, sc.created_at, u.email as candidate_email, u.first_name as candidate_first_name, u.last_name as candidate_last_name, p.address as property_address
FROM solvency_checks sc
JOIN users u ON sc.candidate_id = u.id
JOIN properties p ON sc.property_id = p.id
WHERE sc.initiator_owner_id = $1
ORDER BY sc.created_at DESC
`

type ListSolvencyChecksByOwnerRow struct {
	ID                 int32              `json:"id"`
	InitiatorOwnerID   pgtype.Int4        `json:"initiator_owner_id"`
	CandidateID        pgtype.Int4        `json:"candidate_id"`
	Token              pgtype.Text        `json:"token"`
	PropertyID         pgtype.Int4        `json:"property_id"`
	Status             NullSolvencyStatus `json:"status"`
	CreditSource       pgtype.Text        `json:"credit_source"`
	ScoreResult        pgtype.Int4        `json:"score_result"`
	ReportUrl          pgtype.Text        `json:"report_url"`
	DocumentsJson      []byte             `json:"documents_json"`
	CreatedAt          pgtype.Timestamp   `json:"created_at"`
	CandidateEmail     string             `json:"candidate_email"`
	CandidateFirstName pgtype.Text        `json:"candidate_first_name"`
	CandidateLastName  pgtype.Text        `json:"candidate_last_name"`
	PropertyAddress    string             `json:"property_address"`
}

func (q *Queries) ListSolvencyChecksByOwner(ctx context.Context, initiatorOwnerID pgtype.Int4) ([]ListSolvencyChecksByOwnerRow, error) {
	rows, err := q.db.Query(ctx, listSolvencyChecksByOwner, initiatorOwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSolvencyChecksByOwnerRow
	for rows.Next() {
		var i ListSolvencyChecksByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.InitiatorOwnerID,
			&i.CandidateID,
			&i.Token,
			&i.PropertyID,
			&i.Status,
			&i.CreditSource,
			&i.ScoreResult,
			&i.ReportUrl,
			&i.DocumentsJson,
			&i.CreatedAt,
			&i.CandidateEmail,
			&i.CandidateFirstName,
			&i.CandidateLastName,
			&i.PropertyAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSolvencyChecksByProperty = `-- name: ListSolvencyChecksByProperty :many
SELECT sc.id, sc.initiator_owner_id, sc.candidate_id, sc.token, sc.property_id, sc.status, sc.credit_source, sc.score_result, sc.report_url, sc.documents_json, sc.created_at, u.email as candidate_email, u.first_name as candidate_first_name, u.last_name as candidate_last_name
FROM solvency_checks sc
JOIN users u ON sc.candidate_id = u.id
WHERE sc.property_id = $1
ORDER BY sc.created_at DESC
`

type ListSolvencyChecksByPropertyRow struct {
	ID                 int32              `json:"id"`
	InitiatorOwnerID   pgtype.Int4        `json:"initiator_owner_id"`
	CandidateID        pgtype.Int4        `json:"candidate_id"`
	Token              pgtype.Text        `json:"token"`
	PropertyID         pgtype.Int4        `json:"property_id"`
	Status             NullSolvencyStatus `json:"status"`
	CreditSource       pgtype.Text        `json:"credit_source"`
	ScoreResult        pgtype.Int4        `json:"score_result"`
	ReportUrl          pgtype.Text        `json:"report_url"`
	DocumentsJson      []byte             `json:"documents_json"`
	CreatedAt          pgtype.Timestamp   `json:"created_at"`
	CandidateEmail     string             `json:"candidate_email"`
	CandidateFirstName pgtype.Text        `json:"candidate_first_name"`
	CandidateLastName  pgtype.Text        `json:"candidate_last_name"`
}

func (q *Queries) ListSolvencyChecksByProperty(ctx context.Context, propertyID pgtype.Int4) ([]ListSolvencyChecksByPropertyRow, error) {
	rows, err := q.db.Query(ctx, listSolvencyChecksByProperty, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSolvencyChecksByPropertyRow
	for rows.Next() {
		var i ListSolvencyChecksByPropertyRow
		if err := rows.Scan(
			&i.ID,
			&i.InitiatorOwnerID,
			&i.CandidateID,
			&i.Token,
			&i.PropertyID,
			&i.Status,
			&i.CreditSource,
			&i.ScoreResult,
			&i.ReportUrl,
			&i.DocumentsJson,
			&i.CreatedAt,
			&i.CandidateEmail,
			&i.CandidateFirstName,
			&i.CandidateLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProperty = `-- name: SoftDeleteProperty :one
UPDATE properties
SET is_active = false
WHERE id = $1 AND owner_id = $2 AND is_active = true
RETURNING id
`

type SoftDeletePropertyParams struct {
	ID      int32       `json:"id"`
	OwnerID pgtype.Int4 `json:"owner_id"`
}

func (q *Queries) SoftDeleteProperty(ctx context.Context, arg SoftDeletePropertyParams) (int32, error) {
	row := q.db.QueryRow(ctx, softDeleteProperty, arg.ID, arg.OwnerID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateInvitationStatus = `-- name: UpdateInvitationStatus :exec
UPDATE lease_invitations
SET status = $2
WHERE id = $1
`

type UpdateInvitationStatusParams struct {
	ID     int32       `json:"id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdateInvitationStatus(ctx context.Context, arg UpdateInvitationStatusParams) error {
	_, err := q.db.Exec(ctx, updateInvitationStatus, arg.ID, arg.Status)
	return err
}

const updateLastContext = `-- name: UpdateLastContext :exec
UPDATE users
SET last_context_used = $2
WHERE id = $1
`

type UpdateLastContextParams struct {
	ID              int32       `json:"id"`
	LastContextUsed pgtype.Text `json:"last_context_used"`
}

func (q *Queries) UpdateLastContext(ctx context.Context, arg UpdateLastContextParams) error {
	_, err := q.db.Exec(ctx, updateLastContext, arg.ID, arg.LastContextUsed)
	return err
}

const updateLeaseContractURL = `-- name: UpdateLeaseContractURL :exec
UPDATE leases
SET contract_url = $2
WHERE id = $1
`

type UpdateLeaseContractURLParams struct {
	ID          int32       `json:"id"`
	ContractUrl pgtype.Text `json:"contract_url"`
}

func (q *Queries) UpdateLeaseContractURL(ctx context.Context, arg UpdateLeaseContractURLParams) error {
	_, err := q.db.Exec(ctx, updateLeaseContractURL, arg.ID, arg.ContractUrl)
	return err
}

const updateProperty = `-- name: UpdateProperty :one
UPDATE properties
SET 
  name = COALESCE(NULLIF($3, ''), name),
  address = COALESCE(NULLIF($4, ''), address),
  rental_type = COALESCE(NULLIF($5, '')::property_type, rental_type),
  details = COALESCE($6, details),
  rent_amount = COALESCE($7, rent_amount),
  rent_charges_amount = COALESCE($8, rent_charges_amount),
  deposit_amount = COALESCE($9, deposit_amount),
  is_furnished = COALESCE($10, is_furnished),
  seasonal_price_per_night = COALESCE($11, seasonal_price_per_night)
WHERE id = $1 AND owner_id = $2
RETURNING id, owner_id, name, address, rental_type, details, rent_amount, rent_charges_amount, deposit_amount, is_furnished, seasonal_price_per_night, vacancy_credits, is_active, created_at
`

type UpdatePropertyParams struct {
	ID                    int32          `json:"id"`
	OwnerID               pgtype.Int4    `json:"owner_id"`
	Column3               interface{}    `json:"column_3"`
	Column4               interface{}    `json:"column_4"`
	Column5               interface{}    `json:"column_5"`
	Details               []byte         `json:"details"`
	RentAmount            pgtype.Numeric `json:"rent_amount"`
	RentChargesAmount     pgtype.Numeric `json:"rent_charges_amount"`
	DepositAmount         pgtype.Numeric `json:"deposit_amount"`
	IsFurnished           pgtype.Bool    `json:"is_furnished"`
	SeasonalPricePerNight pgtype.Numeric `json:"seasonal_price_per_night"`
}

func (q *Queries) UpdateProperty(ctx context.Context, arg UpdatePropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, updateProperty,
		arg.ID,
		arg.OwnerID,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Details,
		arg.RentAmount,
		arg.RentChargesAmount,
		arg.DepositAmount,
		arg.IsFurnished,
		arg.SeasonalPricePerNight,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Address,
		&i.RentalType,
		&i.Details,
		&i.RentAmount,
		&i.RentChargesAmount,
		&i.DepositAmount,
		&i.IsFurnished,
		&i.SeasonalPricePerNight,
		&i.VacancyCredits,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const updateSolvencyCheckResult = `-- name: UpdateSolvencyCheckResult :exec
UPDATE solvency_checks
SET status = $2, score_result = $3, report_url = $4
WHERE id = $1
`

type UpdateSolvencyCheckResultParams struct {
	ID          int32              `json:"id"`
	Status      NullSolvencyStatus `json:"status"`
	ScoreResult pgtype.Int4        `json:"score_result"`
	ReportUrl   pgtype.Text        `json:"report_url"`
}

func (q *Queries) UpdateSolvencyCheckResult(ctx context.Context, arg UpdateSolvencyCheckResultParams) error {
	_, err := q.db.Exec(ctx, updateSolvencyCheckResult,
		arg.ID,
		arg.Status,
		arg.ScoreResult,
		arg.ReportUrl,
	)
	return err
}

const updateSubscriptionLimit = `-- name: UpdateSubscriptionLimit :exec
UPDATE subscriptions
SET max_properties_limit = max_properties_limit + $2
WHERE user_id = $1 AND status = 'active'
`

type UpdateSubscriptionLimitParams struct {
	UserID             pgtype.Int4 `json:"user_id"`
	MaxPropertiesLimit pgtype.Int4 `json:"max_properties_limit"`
}

func (q *Queries) UpdateSubscriptionLimit(ctx context.Context, arg UpdateSubscriptionLimitParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionLimit, arg.UserID, arg.MaxPropertiesLimit)
	return err
}

const updateUserPromotion = `-- name: UpdateUserPromotion :exec
UPDATE users
SET password_hash = $2,
    first_name = $3,
    last_name = $4,
    phone_number = $5,
    is_provisional = FALSE
WHERE id = $1
`

type UpdateUserPromotionParams struct {
	ID           int32       `json:"id"`
	PasswordHash pgtype.Text `json:"password_hash"`
	FirstName    pgtype.Text `json:"first_name"`
	LastName     pgtype.Text `json:"last_name"`
	PhoneNumber  pgtype.Text `json:"phone_number"`
}

func (q *Queries) UpdateUserPromotion(ctx context.Context, arg UpdateUserPromotionParams) error {
	_, err := q.db.Exec(ctx, updateUserPromotion,
		arg.ID,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
	)
	return err
}
